<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeneratorHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">team6game</a> &gt; <a href="index.source.html" class="el_package">com.project.team6.model.board.generators.helpers</a> &gt; <span class="el_source">GeneratorHelper.java</span></div><h1>GeneratorHelper.java</h1><pre class="source lang-java linenums">package com.project.team6.model.board.generators.helpers;

import com.project.team6.model.board.Cell;
import com.project.team6.model.board.Position;
import com.project.team6.model.board.generators.BoardGenerator;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.*;

/**
 * Helper methods for generating and validating board terrain.
 * Includes BFS utilities, size checks, wall creation, and file loading.
 */
<span class="nc" id="L17">public class GeneratorHelper {</span>
    // --------------------------------------------------------------------
    // BFS helpers for validation
    // --------------------------------------------------------------------

    /**
     * Checks if a terrain cell can be walked on.
     *
     * @param t terrain type
     * @return true if floor, start, or exit
     */
    public static boolean isPassable(Cell.Terrain t) {
<span class="fc bfc" id="L29" title="All 2 branches covered.">        return switch (t) {</span>
<span class="fc" id="L30">            case WALL, BARRIER -&gt; false;</span>
<span class="fc" id="L31">            default -&gt; true;   // FLOOR, START, EXIT</span>
        };
    }

    /**
     * Runs BFS and counts how many passable cells are reachable.
     * Marks visited cells in the provided matrix.
     *
     * @param terrain terrain grid
     * @param start   starting position
     * @param visited visited flags, same size as terrain
     * @return number of reachable cells
     */
    public static int BFSCount(Cell.Terrain[][] terrain,
                                Position start,
                                boolean[][] visited) {

<span class="fc" id="L48">        Deque&lt;Position&gt; q = new ArrayDeque&lt;&gt;();</span>
<span class="fc" id="L49">        q.addLast(start);</span>
<span class="fc" id="L50">        visited[start.row()][start.column()] = true;</span>

<span class="fc" id="L52">        int count = 0;</span>
<span class="fc bfc" id="L53" title="All 2 branches covered.">        while (!q.isEmpty()) {</span>
<span class="fc" id="L54">            Position p = q.removeFirst();</span>
<span class="fc" id="L55">            count++;</span>

<span class="fc" id="L57">            int column = p.column();</span>
<span class="fc" id="L58">            int row = p.row();</span>

<span class="fc" id="L60">            tryVisit(terrain, visited, q, column + 1, row);</span>
<span class="fc" id="L61">            tryVisit(terrain, visited, q, column - 1, row);</span>
<span class="fc" id="L62">            tryVisit(terrain, visited, q, column, row + 1);</span>
<span class="fc" id="L63">            tryVisit(terrain, visited, q, column, row - 1);</span>
<span class="fc" id="L64">        }</span>
<span class="fc" id="L65">        return count;</span>
    }

    /**
     * Adds a cell to the BFS queue if it is inside the grid, not visited, and passable.
     *
     * @param terrain terrain grid
     * @param visited visited flags
     * @param q       BFS queue
     * @param column       column index
     * @param row       row index
     */
    public static void tryVisit(Cell.Terrain[][] terrain,
                                 boolean[][] visited,
                                 Deque&lt;Position&gt; q,
                                 int column, int row) {
<span class="fc" id="L81">        int rows = terrain.length;</span>
<span class="fc" id="L82">        int cols = terrain[0].length;</span>
<span class="pc bpc" id="L83" title="2 of 8 branches missed.">        if (column &lt; 0 || column &gt;= cols || row &lt; 0 || row &gt;= rows) return;</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (visited[row][column]) return;</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">        if (!isPassable(terrain[row][column])) return;</span>

<span class="fc" id="L87">        visited[row][column] = true;</span>
<span class="fc" id="L88">        q.addLast(new Position(column, row));</span>
<span class="fc" id="L89">    }</span>

    /**
     * Counts how many cells in the grid are passable.
     *
     * @param terrain terrain grid
     * @return number of passable cells
     */
    public static int countPassable(Cell.Terrain[][] terrain) {
<span class="fc" id="L98">        int rows = terrain.length;</span>
<span class="fc" id="L99">        int cols = terrain[0].length;</span>
<span class="fc" id="L100">        int count = 0;</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        for (int row = 0; row &lt; rows; row++) {</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">            for (int column = 0; column &lt; cols; column++) {</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">                if (isPassable(terrain[row][column])) count++;</span>
            }
        }
<span class="fc" id="L106">        return count;</span>
    }

    /**
     * Detects if any passable cell has no passable neighbors.
     *
     * @param terrain terrain grid
     * @return true if an isolated passable cell exists
     */
    public static boolean hasIsolatedFloor(Cell.Terrain[][] terrain) {
<span class="fc" id="L116">        int rows = terrain.length;</span>
<span class="fc" id="L117">        int cols = terrain[0].length;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">        for (int row = 0; row &lt; rows; row++) {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">            for (int column = 0; column &lt; cols; column++) {</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">                if (!isPassable(terrain[row][column])) continue;</span>
<span class="fc" id="L121">                int open = 0;</span>
<span class="pc bpc" id="L122" title="1 of 4 branches missed.">                if (row &gt; 0        &amp;&amp; isPassable(terrain[row - 1][column])) open++;</span>
<span class="pc bpc" id="L123" title="1 of 4 branches missed.">                if (row &lt; rows - 1 &amp;&amp; isPassable(terrain[row + 1][column])) open++;</span>
<span class="fc bfc" id="L124" title="All 4 branches covered.">                if (column &gt; 0        &amp;&amp; isPassable(terrain[row][column - 1])) open++;</span>
<span class="fc bfc" id="L125" title="All 4 branches covered.">                if (column &lt; cols - 1 &amp;&amp; isPassable(terrain[row][column + 1])) open++;</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">                if (open == 0) return true;</span>
            }
        }
<span class="fc" id="L129">        return false;</span>
    }

    // --------------------------------------------------------------------
    // Validation for RANDOM configuration
    // --------------------------------------------------------------------

    /**
     * Validates a barrier layout for the random mode.
     * Requires exit reachability, full connectivity of passable cells, and no isolated floor.
     *
     * @param walls    wall mask
     * @param barriers barrier mask
     * @param start    start position
     * @param exit     exit position
     * @return true if configuration is valid
     */
    public static boolean isBarrierConfigurationValid(boolean[][] walls,
                                                boolean[][] barriers,
                                                Position start,
                                                Position exit) {
<span class="fc" id="L150">        int rows = walls.length;</span>
<span class="fc" id="L151">        int cols = walls[0].length;</span>

<span class="fc" id="L153">        Cell.Terrain[][] terrain =</span>
<span class="fc" id="L154">                toTerrainGrid(rows, cols, walls, barriers, start, exit);</span>

<span class="fc" id="L156">        boolean[][] visited = new boolean[rows][cols];</span>
<span class="fc" id="L157">        int reachable = BFSCount(terrain, start, visited);</span>

        // Exit must be reachable
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        if (!visited[exit.row()][exit.column()]) {</span>
<span class="nc" id="L161">            return false;</span>
        }

        // All passable cells must be connected
<span class="fc" id="L165">        int totalPassable = countPassable(terrain);</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        if (reachable &lt; totalPassable) {</span>
<span class="fc" id="L167">            return false;</span>
        }

        // No isolated floor cells
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (hasIsolatedFloor(terrain)) {</span>
<span class="nc" id="L172">            return false;</span>
        }

<span class="fc" id="L175">        return true;</span>
    }

    // --------------------------------------------------------------------
    // Utility helpers
    // --------------------------------------------------------------------

    /**
     * Checks that board size is at least 3 by 3.
     *
     * @param rows number of rows
     * @param cols number of columns
     * @throws IllegalArgumentException if rows or cols is less than 3
     */
    public static void validateSize(int rows, int cols) {
<span class="pc bpc" id="L190" title="2 of 4 branches missed.">        if (rows &lt; 3 || cols &lt; 3) {</span>
<span class="nc" id="L191">            throw new IllegalArgumentException(&quot;rows/cols must be &gt;= 3&quot;);</span>
        }
<span class="fc" id="L193">    }</span>

    /**
     * Creates a wall mask that surrounds the board.
     *
     * @param rows number of rows
     * @param cols number of columns
     * @return boolean grid with perimeter walls set to true
     */
    public static boolean[][] perimeterWalls(int rows, int cols) {
<span class="fc" id="L203">        boolean[][] walls = new boolean[rows][cols];</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        for (int row = 0; row &lt; rows; row++) {</span>
<span class="fc" id="L205">            walls[row][0]        = true;</span>
<span class="fc" id="L206">            walls[row][cols - 1] = true;</span>
        }
<span class="fc bfc" id="L208" title="All 2 branches covered.">        for (int column = 0; column &lt; cols; column++) {</span>
<span class="fc" id="L209">            walls[0][column]        = true;</span>
<span class="fc" id="L210">            walls[rows - 1][column] = true;</span>
        }
<span class="fc" id="L212">        return walls;</span>
    }

    /**
     * Picks a start position on the west edge, not in a corner.
     *
     * @param rows number of rows
     * @param cols number of columns
     * @param rng  random source
     * @return a start position
     */
    public static Position randomEdgeStart(int rows, int cols, Random rng) {
<span class="fc" id="L224">        int y = 1 + rng.nextInt(rows - 2); // west edge, avoid corners</span>
<span class="fc" id="L225">        return new Position(0, y);</span>
    }

    /**
     * Picks an exit position on the east edge, not in a corner.
     *
     * @param rows number of rows
     * @param cols number of columns
     * @param rng  random source
     * @return an exit position
     */
    public static Position randomEdgeExit(int rows, int cols, Random rng) {
<span class="fc" id="L237">        int row = 1 + rng.nextInt(rows - 2); // east edge, avoid corners</span>
<span class="fc" id="L238">        return new Position(cols - 1, row);</span>
    }

    /**
     * Builds a terrain grid from walls, barriers, and fixed start and exit.
     *
     * @param rows     number of rows
     * @param cols     number of columns
     * @param walls    wall mask
     * @param barriers barrier mask
     * @param start    start position, may be null
     * @param exit     exit position, may be null
     * @return terrain grid
     */
    public static Cell.Terrain[][] toTerrainGrid(int rows, int cols,
                                                  boolean[][] walls,
                                                  boolean[][] barriers,
                                                  Position start,
                                                  Position exit) {
<span class="fc" id="L257">        Cell.Terrain[][] t = new Cell.Terrain[rows][cols];</span>

<span class="fc bfc" id="L259" title="All 2 branches covered.">        for (int row = 0; row &lt; rows; row++) {</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">            for (int column = 0; column &lt; cols; column++) {</span>

<span class="pc bpc" id="L262" title="1 of 6 branches missed.">                if (start != null &amp;&amp; start.column() == column &amp;&amp; start.row() == row) {</span>
<span class="fc" id="L263">                    t[row][column] = Cell.Terrain.START;</span>
<span class="pc bpc" id="L264" title="1 of 6 branches missed.">                } else if (exit != null &amp;&amp; exit.column() == column &amp;&amp; exit.row() == row) {</span>
<span class="fc" id="L265">                    t[row][column] = Cell.Terrain.EXIT;</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">                } else if (walls[row][column]) {</span>
<span class="fc" id="L267">                    t[row][column] = Cell.Terrain.WALL;</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">                } else if (barriers[row][column]) {</span>
<span class="fc" id="L269">                    t[row][column] = Cell.Terrain.BARRIER;</span>
                } else {
<span class="fc" id="L271">                    t[row][column] = Cell.Terrain.FLOOR;</span>
                }
            }
        }
<span class="fc" id="L275">        return t;</span>
    }

    /**
     * Reads all lines from a classpath resource.
     *
     * @param resourcePath path relative to the classpath root
     * @return list of lines in order
     * @throws IllegalArgumentException if the resource is not found
     * @throws RuntimeException if an IO error occurs
     */
    public static List&lt;String&gt; readLinesFromResource(String resourcePath) {
<span class="nc" id="L287">        try (InputStream in = BoardGenerator.class.getClassLoader()</span>
<span class="nc" id="L288">                .getResourceAsStream(resourcePath)) {</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">            if (in == null) {</span>
<span class="nc" id="L290">                throw new IllegalArgumentException(&quot;Resource not found: &quot; + resourcePath);</span>
            }
<span class="nc" id="L292">            try (BufferedReader br = new BufferedReader(new InputStreamReader(in))) {</span>
<span class="nc" id="L293">                List&lt;String&gt; lines = new ArrayList&lt;&gt;();</span>
                String line;
<span class="nc bnc" id="L295" title="All 2 branches missed.">                while ((line = br.readLine()) != null) {</span>
<span class="nc" id="L296">                    lines.add(line);</span>
                }
<span class="nc" id="L298">                return lines;</span>
            }
<span class="nc" id="L300">        } catch (IOException e) {</span>
<span class="nc" id="L301">            throw new RuntimeException(&quot;Error reading resource &quot; + resourcePath, e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>