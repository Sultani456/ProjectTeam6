<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BoardGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">team6game</a> &gt; <a href="index.source.html" class="el_package">com.project.team6.model.board.generators</a> &gt; <span class="el_source">BoardGenerator.java</span></div><h1>BoardGenerator.java</h1><pre class="source lang-java linenums">package com.project.team6.model.board.generators; 

import com.project.team6.model.board.*;
import com.project.team6.model.board.generators.barrierProperties.BarrierOptions;
import com.project.team6.model.board.generators.helpers.GeneratorHelper;

import java.util.*;

/**
 * Builds the first terrain for a board.
 * It does not place rewards, punishments, or enemies. Spawner handles that.
 */
<span class="fc" id="L13">public final class BoardGenerator {</span>

    // --------------------------------------------------------------------
    // Output type
    // --------------------------------------------------------------------

    /**
     * Result of terrain generation.
     * Holds size, start and exit, and the terrain grid.
     */
    public static final class Output {
        private final int rows;
        private final int cols;
        private final Position start;
        private final Position exit;
        private final Cell.Terrain[][] terrain;

        /**
         * Creates an output record.
         *
         * @param rows     number of rows
         * @param cols     number of columns
         * @param start    start position
         * @param exit     exit position
         * @param terrain  terrain grid
         */
        public Output(int rows, int cols,
                      Position start, Position exit,
<span class="fc" id="L41">                      Cell.Terrain[][] terrain) {</span>
<span class="fc" id="L42">            this.rows = rows;</span>
<span class="fc" id="L43">            this.cols = cols;</span>
<span class="fc" id="L44">            this.start = start;</span>
<span class="fc" id="L45">            this.exit = exit;</span>
<span class="fc" id="L46">            this.terrain = terrain;</span>
<span class="fc" id="L47">        }</span>

        /** @return number of rows */
<span class="fc" id="L50">        public int rows() {return rows;}</span>
        /** @return number of columns */
<span class="fc" id="L52">        public int cols() {return cols;}</span>
        /** @return start position */
<span class="fc" id="L54">        public Position start() {return start;}</span>
        /** @return exit position */
<span class="fc" id="L56">        public Position exit() {return exit;}</span>
        /** @return terrain grid */
<span class="fc" id="L58">        public Cell.Terrain[][] terrain() {return terrain;}</span>

    }

    // --------------------------------------------------------------------
    // Public API
    // --------------------------------------------------------------------

    /**
     * Generates a terrain layout based on options.
     *
     * @param opts options for barriers and size
     * @param boardBarrierPercentage target fraction of interior barriers for RANDOM mode
     * @return generated output
     * @throws NullPointerException if opts is null
     */
    public Output generate(BarrierOptions opts, double boardBarrierPercentage) {
<span class="fc" id="L75">        Objects.requireNonNull(opts);</span>

<span class="pc bpc" id="L77" title="2 of 4 branches missed.">        return switch (opts.barrierMode) {</span>
<span class="fc" id="L78">            case NONE      -&gt; generateNone(opts);</span>
<span class="nc" id="L79">            case PROVIDED  -&gt; generateProvided(opts);</span>
<span class="nc" id="L80">            case TEXT      -&gt; generateFromText(opts);</span>
<span class="fc" id="L81">            case RANDOM    -&gt; generateRandomWithConstraints(opts, boardBarrierPercentage);</span>
        };
    }

    // --------------------------------------------------------------------
    // NONE: just perimeter walls, empty interior
    // --------------------------------------------------------------------

    /**
     * Makes a board with only perimeter walls.
     * Interior has no barriers.
     */
    private Output generateNone(BarrierOptions opts) {
<span class="fc" id="L94">        GeneratorHelper.validateSize(opts.rows, opts.cols);</span>
<span class="fc" id="L95">        boolean[][] walls = GeneratorHelper.perimeterWalls(opts.rows, opts.cols);</span>
<span class="fc" id="L96">        boolean[][] barriers = new boolean[opts.rows][opts.cols];</span>

<span class="fc" id="L98">        Random rng = new Random();</span>
<span class="fc" id="L99">        Position start = GeneratorHelper.randomEdgeStart(opts.rows, opts.cols, rng);</span>
<span class="fc" id="L100">        Position exit  = GeneratorHelper.randomEdgeExit(opts.rows, opts.cols, rng);</span>

<span class="fc" id="L102">        Cell.Terrain[][] terrain =</span>
<span class="fc" id="L103">                GeneratorHelper.toTerrainGrid(opts.rows, opts.cols, walls, barriers, start, exit);</span>
<span class="fc" id="L104">        return new Output(opts.rows, opts.cols, start, exit, terrain);</span>
    }

    // --------------------------------------------------------------------
    // PROVIDED: perimeter and programmer provided barrier list
    // --------------------------------------------------------------------

    /**
     * Makes a board with perimeter walls and a provided barrier list.
     * Ignores any barrier placed on the perimeter.
     */
    private Output generateProvided(BarrierOptions opts) {
<span class="nc" id="L116">        GeneratorHelper.validateSize(opts.rows, opts.cols);</span>
<span class="nc" id="L117">        boolean[][] walls    = GeneratorHelper.perimeterWalls(opts.rows, opts.cols);</span>
<span class="nc" id="L118">        boolean[][] barriers = new boolean[opts.rows][opts.cols];</span>

<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (opts.barrierPositions != null) {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">            for (Position p : opts.barrierPositions) {</span>
<span class="nc bnc" id="L122" title="All 4 branches missed.">                if (p.x() &lt;= 0 || p.x() &gt;= opts.cols - 1 ||</span>
<span class="nc bnc" id="L123" title="All 4 branches missed.">                        p.y() &lt;= 0 || p.y() &gt;= opts.rows - 1) {</span>
                    // ignore perimeter; those are already walls
<span class="nc" id="L125">                    continue;</span>
                }
<span class="nc" id="L127">                barriers[p.y()][p.x()] = true;</span>
<span class="nc" id="L128">            }</span>
        }

<span class="nc" id="L131">        Random rng = new Random();</span>
<span class="nc" id="L132">        Position start = GeneratorHelper.randomEdgeStart(opts.rows, opts.cols, rng);</span>
<span class="nc" id="L133">        Position exit  = GeneratorHelper.randomEdgeExit(opts.rows, opts.cols, rng);</span>

<span class="nc" id="L135">        Cell.Terrain[][] terrain =</span>
<span class="nc" id="L136">                GeneratorHelper.toTerrainGrid(opts.rows, opts.cols, walls, barriers, start, exit);</span>
<span class="nc" id="L137">        return new Output(opts.rows, opts.cols, start, exit, terrain);</span>
    }

    // --------------------------------------------------------------------
    // TEXT: read terrain from a level file on the classpath
    // --------------------------------------------------------------------

    /**
     * Loads terrain from a text map.
     * Uses characters to set walls, barriers, start, and exit.
     *
     * @throws NullPointerException if mapResource is null
     * @throws IllegalArgumentException if the map is empty or lines have different length
     */
    private Output generateFromText(BarrierOptions opts) {
<span class="nc" id="L152">        Objects.requireNonNull(opts.mapResource,</span>
                &quot;TEXT mode requires a mapResource (e.g., \&quot;maps/level1.txt\&quot;)&quot;);

<span class="nc" id="L155">        List&lt;String&gt; lines = GeneratorHelper.readLinesFromResource(opts.mapResource);</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (lines.isEmpty()) {</span>
<span class="nc" id="L157">            throw new IllegalArgumentException(&quot;Empty map resource: &quot; + opts.mapResource);</span>
        }

<span class="nc" id="L160">        int rows = lines.size();</span>
<span class="nc" id="L161">        int cols = lines.get(0).length();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        for (String line : lines) {</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            if (line.length() != cols) {</span>
<span class="nc" id="L164">                throw new IllegalArgumentException(&quot;Inconsistent line length in map file.&quot;);</span>
            }
<span class="nc" id="L166">        }</span>

<span class="nc" id="L168">        boolean[][] walls    = new boolean[rows][cols];</span>
<span class="nc" id="L169">        boolean[][] barriers = new boolean[rows][cols];</span>
<span class="nc" id="L170">        Position start = null;</span>
<span class="nc" id="L171">        Position exit  = null;</span>

<span class="nc bnc" id="L173" title="All 2 branches missed.">        for (int y = 0; y &lt; rows; y++) {</span>
<span class="nc" id="L174">            String line = lines.get(y);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">            for (int x = 0; x &lt; cols; x++) {</span>
<span class="nc" id="L176">                char ch = line.charAt(x);</span>
<span class="nc bnc" id="L177" title="All 5 branches missed.">                switch (ch) {</span>
<span class="nc" id="L178">                    case 'X' -&gt; walls[y][x] = true;</span>
<span class="nc" id="L179">                    case '#' -&gt; barriers[y][x] = true;</span>
<span class="nc" id="L180">                    case 'S' -&gt; start = new Position(x, y);</span>
<span class="nc" id="L181">                    case 'E' -&gt; exit  = new Position(x, y);</span>
                    default  -&gt; { /* floor */ }
                }
            }
        }

<span class="nc bnc" id="L187" title="All 4 branches missed.">        if (start == null || exit == null) {</span>
            // fall back to random edges if not provided in file
<span class="nc" id="L189">            Random rng = new Random();</span>
<span class="nc" id="L190">            start = GeneratorHelper.randomEdgeStart(rows, cols, rng);</span>
<span class="nc" id="L191">            exit  = GeneratorHelper.randomEdgeExit(rows, cols, rng);</span>
        }

<span class="nc" id="L194">        Cell.Terrain[][] terrain =</span>
<span class="nc" id="L195">                GeneratorHelper.toTerrainGrid(rows, cols, walls, barriers, start, exit);</span>
<span class="nc" id="L196">        return new Output(rows, cols, start, exit, terrain);</span>
    }

    // --------------------------------------------------------------------
    // RANDOM: perimeter and random internal barriers with constraints
    // --------------------------------------------------------------------

    /**
     * Makes random interior barriers while keeping the board playable.
     * Keeps distance from start and exit and checks connectivity.
     *
     * @param opts options for size
     * @param boardBarrierPercentage target interior fraction for barriers
     * @return generated output
     */
    private Output generateRandomWithConstraints(BarrierOptions opts,
                                                 double boardBarrierPercentage) {
<span class="fc" id="L213">        int rows = opts.rows;</span>
<span class="fc" id="L214">        int cols = opts.cols;</span>
<span class="fc" id="L215">        GeneratorHelper.validateSize(rows, cols);</span>

<span class="fc" id="L217">        Random rng = new Random();</span>

<span class="fc" id="L219">        boolean[][] walls    = GeneratorHelper.perimeterWalls(rows, cols);</span>
<span class="fc" id="L220">        boolean[][] barriers = new boolean[rows][cols];</span>

<span class="fc" id="L222">        Position start = GeneratorHelper.randomEdgeStart(rows, cols, rng);</span>
<span class="fc" id="L223">        Position exit  = GeneratorHelper.randomEdgeExit(rows, cols, rng);</span>

<span class="fc" id="L225">        int interior = (rows - 2) * (cols - 2);</span>
<span class="fc" id="L226">        int targetBarriers = Math.max(0,</span>
<span class="fc" id="L227">                (int) Math.round(interior * boardBarrierPercentage));</span>

<span class="fc" id="L229">        int placed = 0;</span>
<span class="fc" id="L230">        int attempts = 0;</span>
<span class="fc" id="L231">        int maxAttempts = targetBarriers * 20 + 100;</span>

<span class="pc bpc" id="L233" title="1 of 4 branches missed.">        while (placed &lt; targetBarriers &amp;&amp; attempts &lt; maxAttempts) {</span>
<span class="fc" id="L234">            attempts++;</span>

<span class="fc" id="L236">            int x = 1 + rng.nextInt(cols - 2);</span>
<span class="fc" id="L237">            int y = 1 + rng.nextInt(rows - 2);</span>

<span class="pc bpc" id="L239" title="1 of 4 branches missed.">            if (walls[y][x] || barriers[y][x]) continue;</span>

<span class="fc" id="L241">            Position p = new Position(x, y);</span>

            // keep at least Chebyshev 2 away from start and exit
<span class="fc bfc" id="L244" title="All 4 branches covered.">            if (Board.chebyshev(p, start) &lt; 2 || Board.chebyshev(p, exit) &lt; 2) {</span>
<span class="fc" id="L245">                continue;</span>
            }

            // tentatively place barrier
<span class="fc" id="L249">            barriers[y][x] = true;</span>

<span class="fc bfc" id="L251" title="All 2 branches covered.">            if (!GeneratorHelper.isBarrierConfigurationValid(walls, barriers, start, exit)) {</span>
<span class="fc" id="L252">                barriers[y][x] = false; // revert</span>
            } else {
<span class="fc" id="L254">                placed++;</span>
            }
<span class="fc" id="L256">        }</span>

<span class="fc" id="L258">        Cell.Terrain[][] terrain =</span>
<span class="fc" id="L259">                GeneratorHelper.toTerrainGrid(rows, cols, walls, barriers, start, exit);</span>
<span class="fc" id="L260">        return new Output(rows, cols, start, exit, terrain);</span>
    }

    /**
     * Returns a fixed list of barrier positions for the PROVIDED mode.
     *
     * @return list of positions for barriers
     */
    public static ArrayList&lt;Position&gt; barrierList() {
<span class="nc" id="L269">        ArrayList&lt;Position&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L270">        list.add(new Position(4, 2));</span>
<span class="nc" id="L271">        list.add(new Position(13,2));</span>
<span class="nc" id="L272">        list.add(new Position(4,4));</span>
<span class="nc" id="L273">        list.add(new Position(5,4));</span>
<span class="nc" id="L274">        list.add(new Position(12,4));</span>
<span class="nc" id="L275">        list.add(new Position(13,4));</span>
<span class="nc" id="L276">        list.add(new Position(4,6));</span>
<span class="nc" id="L277">        list.add(new Position(8,6));</span>
<span class="nc" id="L278">        list.add(new Position(9,6));</span>
<span class="nc" id="L279">        list.add(new Position(10,6));</span>
<span class="nc" id="L280">        list.add(new Position(7,7));</span>
<span class="nc" id="L281">        list.add(new Position(8,7));</span>
<span class="nc" id="L282">        list.add(new Position(3,8));</span>
<span class="nc" id="L283">        list.add(new Position(4,8));</span>
<span class="nc" id="L284">        list.add(new Position(5,8));</span>
<span class="nc" id="L285">        list.add(new Position(12,8));</span>
<span class="nc" id="L286">        list.add(new Position(13,8));</span>
<span class="nc" id="L287">        list.add(new Position(14,8));</span>

<span class="nc" id="L289">        return list;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>